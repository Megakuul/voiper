package app

import (
	"context"
	"fmt"
	"path/filepath"
	"sync"

	"github.com/emiago/sipgo"
	"github.com/emiago/sipgo/sip"
	"github.com/icholy/digest"
	"github.com/megakuul/voiper/internal/config"
)

type App struct {
	ctx        context.Context
	basePath   string
	configLock sync.Mutex
	config     *config.Config
}

type AppOption func(*App)

func NewApp(opts ...AppOption) *App {
	app := &App{}

	for _, opt := range opts {
		opt(app)
	}

	return app
}

// WithBase adds a base path to the application (used to lookup configs etc).
func WithBase(path string) AppOption {
	return func(a *App) {
		a.basePath = path
	}
}

// startup is called when the app starts. The context is saved
// so we can call the runtime methods
func (a *App) startup(ctx context.Context) {
	a.ctx = ctx
}

func (a *App) ListConfigs() (map[string]bool, error) {
	return config.ListConfigs(a.basePath)
}

func (a *App) AddConfig(cfg *config.Config, name, encryptionKey string) error {
	return config.WriteConfig(cfg, filepath.Join(a.basePath, name), encryptionKey)
}

func (a *App) RemoveConfig(name string, encrypted bool) error {
	return config.RemoveConfig(filepath.Join(a.basePath, name), encrypted)
}

func (a *App) EnableConfig(name, decryptionKey string) error {
	cfg, err := config.LoadConfig(filepath.Join(a.basePath, name), decryptionKey)
	if err != nil {
		return err
	}
	a.configLock.Lock()
	defer a.configLock.Unlock()
	a.config = cfg
	return nil
}

func (a *App) RegisterSIP() error {
	ctx, cancel := context.WithCancel(a.ctx)
	defer cancel()

	agent, err := sipgo.NewUA()
	if err != nil {
		return err
	}
	client, err := sipgo.NewClient(agent)
	if err != nil {
		return err
	}

	req := sip.NewRequest(sip.REGISTER, sip.Uri{
		Scheme: "sip",
		Host:   "10.1.10.252",
	})

	// identity
	req.AppendHeader(&sip.FromHeader{
		DisplayName: "Voiper",
		Address: sip.Uri{
			Scheme:   "sip",
			User:     "voiper",
			Password: "password",
			Host:     "10.1.10.252",
			Port:     5060,
		},
	})

	// which user do i want to register
	req.AppendHeader(&sip.ToHeader{
		DisplayName: "Voiper",
		Address: sip.Uri{
			Scheme: "sip",
			User:   "voiper",
			Host:   "10.1.10.252",
			Port:   5060,
		},
	})

	// not required because we only do one way transactional requests
	// still include it because sip is a fucking legacy crapprotocol
	req.AppendHeader(&sip.ContactHeader{
		Address: sip.Uri{
			User: "voiper",
			Host: "10.1.10.237",
			Port: 5060,
		},
	})

	tx, err := client.TransactionRequest(ctx, req, sipgo.ClientRequestRegisterBuild)
	if err != nil {
		return err
	}
	defer tx.Terminate()

	for {
		select {
		case res, ok := <-tx.Responses():
			if !ok {
				return fmt.Errorf("transaction closed")
			}
			if res.StatusCode == 401 {
				// Get WwW-Authenticate
				wwwAuth := res.GetHeader("WWW-Authenticate")
				chal, err := digest.ParseChallenge(wwwAuth.Value())
				if err != nil {
					println("Fail to parse challenge", "error", err, "wwwauth", wwwAuth.Value)
					return err
				}

				// Reply with digest
				cred, _ := digest.Digest(chal, digest.Options{
					Method:   req.Method.String(),
					URI:      "10.1.10.252",
					Username: "voiper",
					Password: "password",
				})

				newReq := req.Clone()
				newReq.RemoveHeader("Via") // Must be regenerated by tranport layer
				newReq.AppendHeader(sip.NewHeader("Authorization", cred.String()))

				ctx := context.Background()
				tx, err := client.TransactionRequest(ctx, newReq, sipgo.ClientRequestAddVia)
				if err != nil {
					println("Fail to create transaction", "error", err)
					return err
				}
				defer tx.Terminate()

				res, err = getResponse(tx)
				if err != nil {
					println("Fail to get response", "error", err)
					return err
				}

			}
			println(res.StatusCode)
			println(res.Reason)
		case <-ctx.Done():
			return fmt.Errorf("context exceeded")
		}
	}
}
